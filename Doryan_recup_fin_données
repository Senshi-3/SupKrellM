import datetime
import html
import subprocess
import glob
import os

# Fonctions utilitaires

def generer_rapport(modele: str, jetons: dict) -> str:
    sortie = modele
    for cle, valeur in jetons.items():
        sortie = sortie.replace("%%" + cle + "%%", html.escape(str(valeur), quote=True))
    return sortie

def lire_fichier(chemin):
    try:
        with open(chemin, "r", encoding="utf-8", errors="ignore") as f:
            return f.read().strip(), None
    except Exception as e:
        return None, f"{chemin}: {e}"

def formater_duree(secondes_flottantes):
    s = int(secondes_flottantes)
    h, s = divmod(s, 3600)
    m, s = divmod(s, 60)
    j, h = divmod(h, 24)
    if j > 0:
        return f"{j} jours, {h:02d}:{m:02d}:{s:02d}"
    return f"{h:02d}:{m:02d}:{s:02d}"

# Mémoire

def analyser_meminfo():
    texte, err = lire_fichier("/proc/meminfo")
    if err:
        return None, err
    kv = {}
    for ligne in texte.splitlines():
        if ":" in ligne:
            k, v = ligne.split(":", 1)
            kv[k.strip()] = v.strip()

    def ko_vers_gio(texte_val, defaut=0.0):
        try:
            return float(texte_val.split()[0]) / (1024 * 1024)
        except Exception:
            return defaut

    total = ko_vers_gio(kv.get("MemTotal", "0 kB"))
    libre = ko_vers_gio(kv.get("MemFree", "0 kB"))
    tampons = ko_vers_gio(kv.get("Buffers", "0 kB"))
    cache = ko_vers_gio(kv.get("Cached", "0 kB"))
    reclaimable = ko_vers_gio(kv.get("SReclaimable", "0 kB"))
    shmem = ko_vers_gio(kv.get("Shmem", "0 kB"))

    libre_cache = libre + tampons + cache + reclaimable - shmem
    utilisee = max(0.0, total - libre - tampons - cache - reclaimable + shmem)
    pct = (utilisee / total * 100.0) if total > 0 else 0.0

    return {
        "MEM_TOTALE": f"{total:.1f} Go",
        "MEM_UTILISEE": f"{utilisee:.1f} Go",
        "MEM_UTILISEE_PCT": f"{pct:.1f}%",
        "MEM_LIBRE_CACHE": f"{libre_cache:.1f} Go",
    }, None

# Températures

def collecter_temperatures():
    lignes = []
    thermal_zones = glob.glob("/sys/class/thermal/thermal_zone*/temp")
    for tz in thermal_zones:
        try:
            with open(tz, "r") as f:
                temp_milli = int(f.read().strip())
                temp_c = temp_milli / 1000
                nom = tz.split("/")[-2]
                lignes.append(f"<tr><td>{nom}</td><td>{temp_c:.1f} °C</td></tr>")
        except:
            lignes.append(f"<tr><td>{tz}</td><td>N/A</td></tr>")
    if not lignes:
        lignes.append("<tr><td>—</td><td>N/A</td></tr>")
    return "\n".join(lignes)

# Alimentation / Batterie

def collecter_alimentation():
    lignes = []
    try:
        batteries = [d for d in os.listdir("/sys/class/power_supply/") if d.startswith("BAT")]
        if not batteries:
            return "<li>Aucune batterie détectée</li>"
        for bat in batteries:
            try:
                with open(f"/sys/class/power_supply/{bat}/status") as f:
                    status = f.read().strip()
                with open(f"/sys/class/power_supply/{bat}/capacity") as f:
                    cap = f.read().strip()
                lignes.append(f"<li>{bat}: {status}, {cap}%</li>")
            except:
                lignes.append(f"<li>{bat}: N/A</li>")
    except:
        lignes.append("<li>Impossible de lire l’alimentation</li>")
    return "\n".join(lignes)

# Disques

def collecter_disques():
    lignes = []
    try:
        result = subprocess.run(["df", "-h", "--output=source,size,used,avail,pcent,target"], capture_output=True, text=True)
        lines = result.stdout.splitlines()[1:]
        for line in lines:
            parts = line.split()
            if len(parts) == 6:
                lignes.append(f"<tr><td>{parts[0]}</td><td>{parts[1]}</td><td>{parts[2]}</td><td>{parts[3]}</td><td>{parts[4]}</td><td>{parts[5]}</td></tr>")
    except:
        lignes.append("<tr><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>")
    return "\n".join(lignes)

# Processus (top 10 CPU)

def collecter_processus():
    lignes = []
    try:
        result = subprocess.run(["ps", "aux", "--sort=-%cpu"], capture_output=True, text=True)
        lines = result.stdout.splitlines()[1:11]
        for line in lines:
            parts = line.split(None, 10)
            if len(parts) >= 11:
                user, pid, cpu, mem, vsz, rss, tty, stat, start, time, command = parts
                lignes.append(f"<tr><td>{pid}</td><td>{user}</td><td>{cpu}%</td><td>{mem}%</td><td>{command}</td></tr>")
    except:
        lignes.append("<tr><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>")
    return "\n".join(lignes)

# Interfaces réseau

def collecter_interfaces():
    lignes = []
    try:
        with open("/proc/net/dev") as f:
            lines = f.readlines()[2:]
            for line in lines:
                iface, data = line.split(":", 1)
                iface = iface.strip()
                rx_bytes, rx_packets, *_ = data.split()
                lignes.append(f"<tr><td>{iface}</td><td>{int(rx_bytes)/1024:.1f} KB</td><td>{rx_packets}</td></tr>")
    except:
        lignes.append("<tr><td>—</td><td>—</td><td>—</td></tr>")
    return "\n".join(lignes)

# Collecte globale

def collecter_donnees():
    erreurs = []

    date_heure = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    nom_hote, err = lire_fichier("/proc/sys/kernel/hostname")
    if err: erreurs.append(err)
    if not nom_hote: nom_hote = "inconnu"

    noyau, err = lire_fichier("/proc/version")
    if err: erreurs.append(err)
    if not noyau: noyau = "n/a"

    txt_uptime, err = lire_fichier("/proc/uptime")
    if err:
        erreurs.append(err)
        duree_fonctionnement = "n/a"
    else:
        try:
            secondes = float(txt_uptime.split()[0])
            duree_fonctionnement = formater_duree(secondes)
        except Exception as e:
            duree_fonctionnement = "n/a"
            erreurs.append(f"/proc/uptime: {e}")

    mem, err = analyser_meminfo()
    if err:
        erreurs.append(err)
        mem = {
            "MEM_TOTALE": "n/a",
            "MEM_UTILISEE": "n/a",
            "MEM_UTILISEE_PCT": "n/a",
            "MEM_LIBRE_CACHE": "n/a",
        }

    jetons = {
        "NOM_HOTE": nom_hote,
        "DATE_HEURE": date_heure,
        "NOYAU": noyau,
        "DUREE_FONCTIONNEMENT": duree_fonctionnement,
        "MEM_TOTALE": mem["MEM_TOTALE"],
        "MEM_UTILISEE": mem["MEM_UTILISEE"],
        "MEM_UTILISEE_PCT": mem["MEM_UTILISEE_PCT"],
        "MEM_LIBRE_CACHE": mem["MEM_LIBRE_CACHE"],

        "LIGNES_TEMPERATURES": collecter_temperatures(),
        "ELEMENTS_ALIM": collecter_alimentation(),
        "LIGNES_DISQUES": collecter_disques(),
        "LIGNES_PROCESSUS": collecter_processus(),
        "LIGNES_INTERFACES": collecter_interfaces(),

        "ELEMENTS_ERREURS": "<li>Aucune erreur</li>",
    }
    
    return jetons






-------------------------------------------------------------------------------------------------------------------------------------------------------------------

import argparse
import datetime
import glob
import html
import json
import re
import subprocess
from pathlib import Path


JETONS_BRUTS = {
    "LIGNES_TEMPERATURES",
    "ELEMENTS_ALIM",
    "LIGNES_DISQUES",
    "LIGNES_PROCESSUS",
    "LIGNES_INTERFACES",
    "ELEMENTS_CONNEXIONS",
    "LIGNES_WEB",
    "ELEMENTS_ERREURS",
}

def faire_rapport(modele: str, jetons: dict) -> str:
    rendu = modele
    for cle, val in jetons.items():
        if cle in JETONS_BRUTS:
            texte = str(val)
        else:
            texte = html.escape(str(val), quote=True)
        rendu = rendu.replace("%%" + cle + "%%", texte)
    rendu = re.sub(r"%%[A-Z0-9_]+%%", "", rendu)
    return rendu

def lire_fichier(chemin: str):
    try:
        with open(chemin, "r", encoding="utf-8", errors="ignore") as f:
            return f.read().strip(), None
    except Exception as err:
        return None, f"{chemin}: {err}"

def format_duree(sec_f: float) -> str:
    s = int(sec_f)
    h, s = divmod(s, 3600)
    m, s = divmod(s, 60)
    j, h = divmod(h, 24)
    if j > 0:
        return f"{j} jours, {h:02d}:{m:02d}:{s:02d}"
    return f"{h:02d}:{m:02d}:{s:02d}"

def lire_memoire():
    txt, err = lire_fichier("/proc/meminfo")
    if err:
        return None, err
    kv = {}
    for ligne in txt.splitlines():
        if ":" in ligne:
            k, v = ligne.split(":", 1)
            kv[k.strip()] = v.strip()

    def ko_vers_gio(texte_val, defaut=0.0):
        try:
            return float(texte_val.split()[0]) / (1024 * 1024)
        except Exception:
            return defaut

    total = ko_vers_gio(kv.get("MemTotal", "0 kB"))
    libre = ko_vers_gio(kv.get("MemFree", "0 kB"))
    tampons = ko_vers_gio(kv.get("Buffers", "0 kB"))
    cache = ko_vers_gio(kv.get("Cached", "0 kB"))
    reclaim = ko_vers_gio(kv.get("SReclaimable", "0 kB"))
    shmem = ko_vers_gio(kv.get("Shmem", "0 kB"))
    libre_cache = libre + tampons + cache + reclaim - shmem
    utilise = max(0.0, total - libre - tampons - cache - reclaim + shmem)
    pct = (utilise / total * 100.0) if total > 0 else 0.0
    return {
        "MEM_TOTALE": f"{total:.1f} Go",
        "MEM_UTILISEE": f"{utilise:.1f} Go",
        "MEM_UTILISEE_PCT": f"{pct:.1f}%",
        "MEM_LIBRE_CACHE": f"{libre_cache:.1f} Go",
    }, None

def prendre_temperatures() -> str:
    lignes = []
    zones = sorted(glob.glob("/sys/class/thermal/thermal_zone*/temp"))
    for tz in zones:
        try:
            with open(tz, "r") as f:
                brut = f.read().strip()
            t_milli = int(brut)
            t_c = t_milli / 1000.0
            nom = Path(tz).parent.name
            lignes.append(
                "<tr><td>"
                f"{nom}</td><td>{t_c:.1f} °C</td>"
                "<td><span class='badge ok'>OK</span></td></tr>"
            )
        except Exception:
            lignes.append(
                "<tr><td>"
                f"{tz}</td><td>N/A</td>"
                "<td><span class='badge err'>N/A</span></td></tr>"
            )
    if not lignes:
        lignes.append(
            "<tr><td>—</td><td>N/A</td><td><span class='badge'>N/A</span></td></tr>"
        )
    return "\n".join(lignes)

def prendre_alim() -> str:
    lignes = []
    bats = sorted(glob.glob("/sys/class/power_supply/BAT*"))
    if not bats:
        return "<li>Aucune batterie détectée</li>"
    for bat in bats:
        try:
            with open(f"{bat}/status", "r") as f:
                etat = f.read().strip()
        except Exception:
            etat = "N/A"
        try:
            with open(f"{bat}/capacity", "r") as f:
                cap = f.read().strip()
        except Exception:
            cap = "N/A"
        nom = Path(bat).name
        lignes.append(f"<li>{nom}: {etat} — {cap}%</li>")
    return "\n".join(lignes)

def prendre_disques() -> str:
    try:
        res = subprocess.run(
            ["df", "-T", "-hP"],
            capture_output=True,
            text=True,
            timeout=3,
        )
        lignes = []
        for line in res.stdout.splitlines()[1:]:
            parts = line.split()
            if len(parts) >= 7:
                dev, fstype, size, used, free, pcent, mnt = parts[:7]
                lignes.append(
                    "<tr>"
                    f"<td>{dev}</td><td>{mnt}</td><td>{pcent}</td>"
                    f"<td>{free}</td><td>{fstype}</td>"
                    "</tr>"
                )
        if not lignes:
            return "<tr><td colspan='5'>N/A</td></tr>"
        return "\n".join(lignes)
    except Exception:
        return "<tr><td colspan='5'>N/A</td></tr>"

def prendre_processus() -> str:
    try:
        res = subprocess.run(
            ["ps", "aux", "--sort=-%cpu"],
            capture_output=True,
            text=True,
            timeout=3,
        )
        lignes = []
        for line in res.stdout.splitlines()[1:11]:
            parts = line.split(None, 10)
            if len(parts) >= 11:
                user, pid, cpu, mem, vsz, rss, tty, stat, start, t, cmd = parts
                cmd_ok = html.escape(cmd)[:120]
                lignes.append(
                    "<tr>"
                    f"<td>{pid}</td><td>{user}</td>"
                    f"<td>{cpu}%</td><td>{mem}%</td>"
                    f"<td>{cmd_ok}</td>"
                    "</tr>"
                )
        if not lignes:
            return "<tr><td colspan='5'>N/A</td></tr>"
        return "\n".join(lignes)
    except Exception:
        return "<tr><td colspan='5'>N/A</td></tr>"

def prendre_interfaces() -> str:
    ip4 = {}
    ip6 = {}
    try:
        res = subprocess.run(
            ["ip", "-j", "addr"],
            capture_output=True,
            text=True,
            timeout=2,
        )
        for ifc in json.loads(res.stdout):
            nom = ifc.get("ifname")
            for adr in ifc.get("addr_info", []):
                fam = adr.get("family")
                if fam == "inet":
                    ip4.setdefault(nom, []).append(adr.get("local"))
                elif fam == "inet6":
                    ip6.setdefault(nom, []).append(adr.get("local"))
    except Exception:
        pass

    rxtx = {}
    try:
        with open("/proc/net/dev", "r") as f:
            for line in f.readlines()[2:]:
                if ":" not in line:
                    continue
                iface, rest = line.split(":", 1)
                nom = iface.strip()
                nums = rest.split()
                rx = int(nums[0]) if nums else 0
                tx = int(nums[8]) if len(nums) > 8 else 0
                rxtx[nom] = (rx, tx)
    except Exception:
        pass

    lignes = []
    noms = sorted(set(list(rxtx.keys()) + list(ip4.keys()) + list(ip6.keys())))
    for nom in noms:
        ip_v4 = ", ".join(ip4.get(nom, [])) or "—"
        ip_v6 = ", ".join(ip6.get(nom, [])) or "—"
        rx, tx = rxtx.get(nom, (0, 0))
        try:
            with open(f"/sys/class/net/{nom}/operstate", "r") as f:
                etat = f.read().strip()
        except Exception:
            etat = "N/A"
        lignes.append(
            "<tr>"
            f"<td>{nom}</td>"
            f"<td>{ip_v4}</td>"
            f"<td>{ip_v6}</td>"
            f"<td>{rx//1024}K / {tx//1024}K</td>"
            f"<td><span class='badge'>{etat}</span></td>"
            "</tr>"
        )
    if not lignes:
        return "<tr><td colspan='5'>N/A</td></tr>"
    return "\n".join(lignes)

def prendre_connexions() -> str:
    try:
        res = subprocess.run(
            ["ss", "-tuln"],
            capture_output=True,
            text=True,
            timeout=2,
        )
        lignes = []
        for line in res.stdout.splitlines()[1:]:
            lignes.append(f"<li>{html.escape(line)}</li>")
        if not lignes:
            return "<li>Aucune connexion</li>"
        return "\n".join(lignes)
    except Exception:
        return "<li>N/A</li>"

def prendre_web() -> str:
    lignes = []
    try:
        res = subprocess.run(
            ["ss", "-ntlp"],
            capture_output=True,
            text=True,
            timeout=2,
        )
        for ligne in res.stdout.splitlines():
            if ":80 " in ligne or ":443 " in ligne:
                lignes.append(
                    "<tr>"
                    f"<td>{html.escape(ligne)}</td>"
                    "<td>—</td><td>—</td><td>—</td><td>—</td>"
                    "<td><span class='badge ok'>OK</span></td>"
                    "</tr>"
                )
        if not lignes:
            return "<tr><td colspan='6'>Aucun service web détecté</td></tr>"
        return "\n".join(lignes)
    except Exception:
        return "<tr><td colspan='6'>N/A</td></tr>"

def prendre_tout():
    erreurs = []
    date_heure = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    nom_hote, err = lire_fichier("/proc/sys/kernel/hostname")
    if err:
        erreurs.append(err)
    if not nom_hote:
        nom_hote = "inconnu"

    noyau, err = lire_fichier("/proc/version")
    if err:
        erreurs.append(err)
    if not noyau:
        noyau = "n/a"

    txt_uptime, err = lire_fichier("/proc/uptime")
    if err:
        erreurs.append(err)
        duree = "n/a"
    else:
        try:
            secs = float(txt_uptime.split()[0])
            duree = format_duree(secs)
        except Exception as e:
            duree = "n/a"
            erreurs.append(f"/proc/uptime: {e}")

    mem, err = lire_memoire()
    if err:
        erreurs.append(err)
        mem = {
            "MEM_TOTALE": "n/a",
            "MEM_UTILISEE": "n/a",
            "MEM_UTILISEE_PCT": "n/a",
            "MEM_LIBRE_CACHE": "n/a",
        }

    jetons = {
        "NOM_HOTE": nom_hote,
        "DATE_HEURE": date_heure,
        "NOYAU": noyau,
        "DUREE_FONCTIONNEMENT": duree,
        "MEM_TOTALE": mem["MEM_TOTALE"],
        "MEM_UTILISEE": mem["MEM_UTILISEE"],
        "MEM_UTILISEE_PCT": mem["MEM_UTILISEE_PCT"],
        "MEM_LIBRE_CACHE": mem["MEM_LIBRE_CACHE"],
        "LIGNES_TEMPERATURES": prendre_temperatures(),
        "ELEMENTS_ALIM": prendre_alim(),
        "LIGNES_DISQUES": prendre_disques(),
        "LIGNES_PROCESSUS": prendre_processus(),
        "LIGNES_INTERFACES": prendre_interfaces(),
        "ELEMENTS_CONNEXIONS": prendre_connexions(),
        "LIGNES_WEB": prendre_web(),
        "ELEMENTS_ERREURS": (
            "\n".join(f"<li>{html.escape(e)}</li>" for e in erreurs)
            if erreurs
            else "<li>Aucune erreur</li>"
        ),
    }
    return jetons
